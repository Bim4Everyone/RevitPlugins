# Code Style Guide

За основу взят
[C# at Google Style Guide](https://google.github.io/styleguide/csharp-style.html).

Данный гайд описывает основные требования к стилю кода на C# в рамках разработки плагинов для платформы Bim4Everyone.

## Рекомендации по форматированию кода

### Правила именования

Правила именования основаны на соответствующих 
[правилах от Microsoft](https://learn.microsoft.com/en-us/dotnet/standard/design-guidelines/naming-guidelines).  
Для случаев, которые правила Microsoft не затрагивают, используются
[правила CodeFX](https://github.com/dotnet/runtime/blob/master/docs/coding-guidelines/coding-style.md).

Основные правила:

#### Код

*   Для имен классов, методов, перечислений, публичных полей и свойств, пространств имен используется `PascalCase`.
*   Для имен локальных переменных, параметров используется `camelCase`.
*   Для полей и свойств с модификаторами доступа private, protected, internal 
    и protected internal используется `_camelCase`.
*   Такие модификаторы, как const, static, readonly и т.д. не влияют на правила именования.
*   Если имя состоит из нескольких слов, то каждое слово начинается с большой буквы. При этом словом считается 
    всё, что пишется без пробелов в обычном тексте, в том числе, аббревиатуры. 
    Например, должно быть `MyRpc` вместо ~~`MyRPC`~~. 
    При этом общепринятые аббревиатуры можно полностью писать большими буквами, 
    например, `SomeElementVM` вместо `SomeElementViewModel`.
*   Имена интерфейсов начинаются с символа `I`, например, `IInterface`.

#### Файлы

*   Для имен файлов и папок используется `PascalCase`, например, `MyFile.cs`.
*   Где это возможно, имя файла должно совпадать с основным классом в этом файле, 
    например, `MyClass.cs`.
*   Старайтесь создавать один основной класс в одном файле.

### Организация кода

*   Модификаторы доступа создаются в следующем порядке: `public, private, protected, internal, file, new, static, 
    abstract, virtual, sealed, readonly, override, extern, unsafe, volatile, async, required`.
*   Добавление пространств имен через using всегда идет сверху, перед всем остальным кодом. 
    Директивы `using` добавляются в алфавитном порядке, кроме импортов `System` и `Windows`, 
    которые всегда должны идти первыми.
*   Порядок членов класса:
    *   Группировать члены класса в следующем порядке:
        *   Вложенные классы, перечисления, делегаты, события.
        *   Поля (сначала должны идти const, static, readonly).
        *   Конструкторы и деструкторы.
        *   Свойства.
        *   Методы.
    *   В каждой группе элементы должны располагаться в следующем порядке:
        *   Public.
        *   Internal.
        *   Protected internal.
        *   Protected.
        *   Private protected.
        *   Private.
    *   Где это возможно, группируйте реализации интерфейсов вместе.
*   Не используйте директивы `#region` в коде. 
    Если часть кода можно объединить в `#region`, то возможно этот код нужно вынести в отдельный класс.

### Правила расстановки пробелов

*   Максимум одно выражение в строке.
*   Максимум одно присваивание в строке.
*   Используется не более четырех уровней вложенности кода
*   Отступы кратны 4 пробелам, Tab не используется.
*   Максимальное число символов в строке: 120.
*   Нет перехода на новую строку перед открывающейся фигурной скобкой.
*   Нет перехода на новую строку между закрывающейся фигурной скобкой и else / catch / finally.
*   Фигурные скобки используется, даже если они не обязательны.
*   После запятых ставится пробел.
*   Нет пробелов после открывающейся скобкой и перед закрывающейся скобкой.
*   Нет пробелов между унарным оператором и его операндом. 
    Один пробел между оператором и операндом во всех остальных случаях.
*   Правила переноса строк:
    *   Если длинное выражение не помещается на 1 строку, 
        то к каждой новой строке добавляется отступ кратно 4 пробелам.
    *   При определении и вызове методов, если аргументы не умещаются в одной строке, они должны быть 
        разбиты на несколько строк. Каждая последующая строка выравнивается по первому аргументу. 
        Если для этого не хватает места, то все аргументы могут быть вместе перенесены на следующую строку 
        с отступом в 4 пробела.


### Example

```c#
using System;                                           // `using` находится сверху, вне объявления namespace.

namespace MyNamespace {                                 // Для namespace используется PascalCase.
    public interface IMyInterface {                     // Имя интерфейса начинается с 'I'.
        public int Calculate(float value, float exp);   // Для метода используется PascalCase
                                                        // ...и после запятой ставится пробел.
    }

    public enum MyEnum {                                // Для перечислений используется PascalCase.
        Yes,
        No,
    }

    public class MyClass {                              // Для класса используется PascalCase.
        private const int _bar = 100;                   // const не влияют на правила именования.
        private readonly bool _noCounting;              // Для приватных членов класса используется _camelCase.  
        private readonly Results _results;
        private int _foo;

        public MyClass() {                              
            _results = new Results {
                NumNegativeResults = 1,                 // При переходе на новую строку добавляются 4 пробела.
                NumPositiveResults = 1,
            };

            _noCounting = false;
        }

        public Results Results => _results;             // Для публичных членов класса используется PascalCase.
        public bool NoCounting => _noCounting;
        public int Foo { 
            get => _foo; 
            set => _foo = value; 
        }

        public int CalculateValue(int mulNumber) {      // Нет перехода на новую строку перед символом '{'.
            var resultValue = Foo * mulNumber;          // Для локальных переменных используется camelCase.
            _foo += _bar;

            if(!NoCounting) {                           // Нет пробелов перед унарным оператором.
                if(resultValue < 0) {                   // Пробелы вокруг оператора сравнения.                                                        
                    _results.NumNegativeResults++;      // Фигурные скобки используются,
                                                        // ...даже, если они необязательны.
                } else if(resultValue > 0) {            // Нет перехода на новую строку между '}' и else.
                    _results.NumPositiveResults++;
                }
            }

            return resultValue;
        }

        public void ExpressionBodies() {
            // Простые лямбда-выражения помещайте в одну строку, если это возможно.
            Func<int, int> increment = x => x + 1;

            // Закрывающая фигурная скобка выравнивается по первому символу строки с открывающей скобкой.
            Func<int, int, long> difference1 = (x, y) => {
                long diff = (long) x - y;
                return diff >= 0 ? diff : -diff;
            };

            // Если определенние переносится на новую строку, то отступ имеет все тело объекта.
            Func<int, int, long> difference2 =
                (x, y) => {
                    long diff = (long) x - y;
                    return diff >= 0 ? diff : -diff;
                };

            // Встроенные лямбда-аргументы тоже следуют этому правилу. Предпочитайте дополнительную
            // новую строку перед группой аргументов, которые включают лямбда-выражение.
            CallWithDelegate(
                (x, y) => {
                    long diff = (long) x - y;
                    return diff >= 0 ? diff : -diff;
                });
        }

        // Пустые блоки могут быть краткими.
        public void DoNothing() { }

        // Старайтесь выравнивать аргументы на новой строке по первому аргументу.
        public void AVeryLongFunctionNameThatCausesLineWrappingProblems(int longArgumentName,
                                                                        int p1, int p2) { }

        // Если перенос части аргументов не дает достаточно места, то могут быть перенесены 
        // все аргументы с отступом в 4 пробела.
        public void AnotherLongFunctionNameThatCausesLineWrappingProblems(
            int longArgumentName, int longArgumentName2, int longArgumentName3) { }

        public void CallingLongFunctionName() {
            int veryLongArgumentName = 1234;
            int shortArg = 1;
            // Старайтесь выравнивать аргументы на новой строке по первому аргументу.
            AnotherLongFunctionNameThatCausesLineWrappingProblems(shortArg, shortArg,
                                                                  veryLongArgumentName);

            // Если перенос части аргументов не дает достаточно места, то могут быть перенесены 
            // все аргументы с отступом в 4 пробела.
            AnotherLongFunctionNameThatCausesLineWrappingProblems(
                veryLongArgumentName, veryLongArgumentName, veryLongArgumentName);
        }
    }
}
```


## Рекомендации по написанию кода на C#

### Константы

*   Переменные и поля, которые могут быть сделаны const, всегда следует делать `const`.
*   Если `const` не подходит, то `readonly` может быть подходящей альтернативой.
*   Предпочитайте именованные константы «магическим числам и словам».

### IEnumerable vs IList vs IReadOnlyList

*   В качестве входящих данных используйте самый строгий тип коллекции, например, 
    `IReadOnlyCollection` / `IReadOnlyList` / `IEnumerable`, как входные данные методов, 
    если входные данные должны быть неизменными.
*   Для возвращаемых данных, когда коллекция полностью передается во владение вызывающему методу, 
    предпочитайте `IList`, а не `IEnumerable`. 
    Если коллекция на самом деле находится в коде, который вызывается, т.е. если коллекция - 
    это внутренний член объекта, на котором был вызван метод по получению этой коллекции, 
    то необходимо использовать самый строгий вариант.

### Итераторы vs коллекци

*   Выбирайте лучший вариант, учитывая следующее:
    *   Итератор может быть более производительным, если результаты будут 
        обрабатываться лениво, например, если не требуются все результаты.
    *   Итератор напрямую обращенный в коллекцию с помощью `ToList()` 
        будет менее производительным, чем непосредственное заполнение коллекции.
    *   Следует избегать ситуаций, когда итератор вызываетсянесколько раз.

### Стили свойств

*   Для одиночных readonly свойств предпочтительнее использовать тело-выражение (`=>`), где это возможно.
*   Для остальных случаев используйте более старый `{ get; set; }` синтаксис.

### Синтаксис тела-выражения

Пример:

```c#
int SomeProperty => _someProperty
```

*   Разумно используйте тело-выражение в лямбдах и свойствах.
*   Не рекомендуется использовать тело-выражение в определениях методов.

### Структуры и классы:

*   Структуры очень сильно отличаются от классов:

    *   Структуры всегда передаются и возвращаются по значению.
    *   Присвоение значение члену структуры, которая была возвращена не изменяет оригинал. 
        Пример: `transform.position.x = 10`, не установит значение свойству transform.position.x значение 10,
        потому что `position` возвращается в этом случае как значение, т.е. значение устанавливается копии оригиналу.

*   Почти всегда используйте классы.

*   Рассмотрите структуру для использования, когда тип можно рассмотреть как другие типы значений, 
    например, если экземпляры типа маленькие и обычно недолго существуют или когда обычно встроены в другие объекты. 
    Хорошими примерами реализации являются
    [Vector3](https://learn.microsoft.com/en-us/dotnet/api/system.numerics.vector3?view=net-8.0), 
    [Quaternion](https://learn.microsoft.com/en-us/dotnet/api/system.numerics.quaternion?view=net-8.0) и 
    [Bounds](https://learn.microsoft.com/en-us/dotnet/api/microsoft.azure.remoterendering.bounds?view=remoterendering).

### Лямбды vs именованные методы

*    Если лямбда-выражение не очевидное (например, несколько выражений без учета объявлений) 
     или используется в нескольких местах, то это скорее всего должен быть именованный метод.


### Инициализаторы полей

*   Инициализаторы полей обычно рекомендуются к использованию.

### Методы-расширения

*   Используйте методы-расширения только, когда исходный код класса недоступен 
    или когда изменение исходного кода не представляется возможным.
*   Используйте методы-расширения только, если добавляемый функционал является
    «основной» функцией, которую было бы целесообразно добавить к исходному классу.
    *   Обратите внимание, если у нас есть доступ к источнику расширяемого класса 
        и его владелец не хочет добавлять функционал, то лучше не использовать методы расширения.
*   Добавляете методы-расширения только в библиотеки, которые доступны отовсюду – расширения, 
    которые доступны только в части кода создадут проблемы читаемости.
*   Имейте в виду, что методы расширения всегда запутывают код. Поэтому лучше не добавлять их.

### ref и out

*   Не рекомендуется использовать ref и out.

### LINQ

*   Предпочитайте использовать LINQ-цепочки вместо императивного кода.
*   Предпочитайте методы-расширения ключевым словам в SQL-стиле, 
    например, предпочтительнее `myList.Where(x)`, чем `myList where x`.
*   Избегайте `Container.ForEach(...)` для чего угодно длиннее одного выражения.

### Array vs List

*   В основном предпочитайте `List<>` массивам для публичных переменных, свойств 
    и возвращаемых типов (держите в уме рекомендации по `IList` / `IEnumerable` / `IReadOnlyList`, описанные выше)
*   Предпочитайте `List<>`, когда размер коллекции может измениться.
*   Предпочитайте массивы, когда размер коллекции фиксированный и известен в момент создания.
*   Предпочитайте массив для многомерных массивов.
*   Обратите внимание:
    *   Массив и `List<>` оба представляют линейные, смежные коллекции.
    *   Подобно arrays и `std::vector` в C++, массивы фиксированы по вместимости, а `List<>` может быть расширен.
    *   В большинстве случаев массивы более производительны, но в основном `List<>` более гибкий.

### Папки и расположение файлов

*   Предпочитайте плоскую структуру, где это возможно.

### Использование tuple как возвращаемое значение

*   Используйте именованные кортежи вместо встроенных, но лучше создать класс
*   В основном предпочитайте именованные классы типу кортежам, особенно при возврате сложных типов.

### String interpolation vs `String.Format()` vs `String.Concat` vs `operator+`

*   Старайтесь всегда использовать интерполяцию строк, если это возможно. 
    В остальных случаях и при работе с большим объемом текста рекомендуется 
    использовать StringBuilder вместо конкатенации строки.

### `using`

*   В основном не используйте длинные псевдонимы с `using`. 
    Часто это признак того, что кортеж `Tuple<>` должен быть обращен в класс.
    *   Например, `using RecordList = List<Tuple<int, float>>` 
        возможно должен быть именованным классом.

### Наименование пространств имен

*   В основном пространства имен не должны быть в глубину больше 2 уровней
*   Старайтесь делать соответствие структуры файлов/папок пространствам имен.
*   Для общедоступных библиотек/модулей кода используйте пространства имен. 
*   Новые пространства имен верхнего уровня должны быть узнаваемы и уникальны.

### Значения по умолчанию, возвращение null для структур

*   Параметр `out` допускается использовать только в методах типа “TryGet”, 
    например, `success = int.TryParse(value, out number)`
*   Рекомендуется использовать тернарный оператор, если есть такая возможность и это увеличивает читаемость кода.
*   Рекомендуется добавлять проверки на null для типов, допускающих null. 
    Варианты проверки на null:
    *   Null-conditional operator, например, `width = element?.width`.
    *   Null-coalescing operators, например, `name = text ?? "UserName" и name ??= "UserName"`.
    

### Удаление из коллекции во время итерации

C# (как и большинство других языков) не предоставляет очевидный механизм 
для удаления объектов в процессе итерации. Существует несколько вариантов:

*   Если все, что требуется это удалить некоторые элементы, удовлетворяющие какому-то условию, 
    рекомендуется использовать `someList.RemoveAll(somePredicate)`.
*   Если требуются другие действия в процессе итерации, `RemoveAll` может быть недостаточно. 
    Общий альтернативный шаблон — это создать новую коллекцию вне цикла, добавлять необходимые элементы 
    в новую коллекцию и заменить исходную коллекцию на новую после итерации. 
    Для этого нужно использовать LINQ и метод Where.

### Вызов делегатов

*   При вызове делегата используйте `Invoke()` и оператор null-conditional, то есть `SomeDelegate?.Invoke()`. 
    Это лучше отражает вызов делегата, и его сложно будет спутать с методом.

### Ключевое слов `var`

*   Использование `var` приветствуется, если это способствует повышению читаемости 
    и позволяет избежать шумных, очевидных и неважных имен типов.

*   Приветствуется:

    *   Когда тип очевиден, например, `var apple = new Apple();`, или `var
        request = Factory.Create<HttpRequest>();`
    *   Для временных переменных, которые только проходят через другие методы, 
        например, `var item = GetItem(); ProcessItem(item);`

*   Не приветствуется:

    *   При работе с базовыми типами, например, `var success = true;`
    *   При работе с встроенными числовыми переменными, которые определяются компилятором, 
        например, `var number = 12 * ReturnsFloat();`
    *   Когда пользователи точно получат пользу от того, что знают тип, например, 
        `var listOfItems = GetList();`

### Атрибуты

*   Атрибуты должны появляться на строке выше поля, свойства или метода, 
    к которому они относятся, с переходом на новую строку. 
    При этом атрибуты должны размещаться после комментариев.
*   Каждый атрибут должен начинаться с новой строки. Это позволяет легче добавлять или 
    удалять атрибуты и обеспечивает удобный поиск каждого атрибута.

### Именование аргументов

Когда значение аргумента метода не очевидно, рассмотрите один из следующих принципов:

*   Если аргумент — это литерал, и эта константа используется в нескольких вызовах методов способом,
    который предполагает, что они идентичны, используйте именованную константу,
    чтобы сделать это ограничение явным и гарантировать, что оно выполняется.
*   Рассмотрите изменение сигнатуры метода, чтобы заменить bool аргументы на enum аргументы.
    Это поможет понять, что значат эти аргументы.
*   Замените большие и сложные вложенные выражения именованными переменными.

*   Рассмотрите возможность использования
    [именованных аргументов](https://learn.microsoft.com/en-us/dotnet/csharp/programming-guide/classes-and-structs/named-and-optional-arguments)
    для прояснения значений аргументов при вызове.
*   Для методов, которые имеют несколько параметров конфигурации, рассмотрите создание класса или структуры
    для хранения всех этих параметров и использование экземпляра в качестве аргумента.
    Это имеет несколько преимуществ. Параметры упоминаются по имени при вызове, что проясняет их значение.
    Также это снижает количество аргументов метода, что позволяет проще читать и создавать вызов метода.
    Как дополнительное преимущество, это позволяет не менять вызов метода при добавлении нового параметра.

Рассмотрим пример:

```c#
// Плохо - что это за аргументы?
DecimalNumber product = CalculateProduct(values, 7, false, null);
```

против:

```c#
// Хорошо
ProductOptions options = new ProductOptions();
options.PrecisionDecimals = 7;
options.UseCache = CacheUsage.DontUseCache;
DecimalNumber product = CalculateProduct(values, options, completionDelegate: null);
```