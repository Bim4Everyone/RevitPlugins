# Code Style Guide

Данный гайд описывает основные требования к стилю кода на C# в рамках разработки плагинов для платформы Bim4Everyone.


## Рекомендации по форматированию кода

### Правила именования

Правила именования основаны на соответствующих 
[правилах от Microsoft](https://learn.microsoft.com/ru-ru/dotnet/standard/design-guidelines/naming-guidelines).
Для случаев, которые правила Microsoft не затрагивают, используются
[правила CodeFX](https://github.com/dotnet/runtime/blob/master/docs/coding-guidelines/coding-style.md)

Основные правила:

#### Код

*   Для имен классов, методов, перечислений, публичных полей и свойств, пространств имен используется `PascalCase`.
*   Для имен локальных переменных, параметров используется `camelCase`.
*   Для полей и свойств с модификаторами доступа private, protected, internal 
    и protected internal используется `_camelCase`.
*   Такие модификаторы, как const, static, readonly и т.д. не влияют на правила именования.
*   Если имя состоит из нескольких слов, то каждое слово начинается с большой буквы. При этом словом считается, 
    всё что пишется без пробелов в обычном тексте, в том числе, аббревиатуры. 
    Например, должно быть `MyRpc` вместо ~~`MyRPC`~~.
*   Имена интерфейсов начинаются с символа `I`, например, `IInterface`.

#### Файлы

*   Для имен файлов и папок используется `PascalCase`, например, `MyFile.cs`.
*   Где это возможно, имя файла должно совпадать с основным классом в этом файле, 
    например, `MyClass.cs`.
*   Старайтесь создавать один основной класс в одном файле.

### Организация кода

*   Модификаторы доступа создаются в следующем порядке: `public, private, protected, internal, file, new, static, 
    abstract, virtual, sealed, readonly, override, extern, unsafe, volatile, async, required`.
*   Добавление пространств имен через using всегда идет сверху, перед всем остальным кодом. 
    Директивы `using` добавляются в алфавитном порядке, кроме импортов `System` и `Windows`, 
    которые всегда должны идти первыми.
*   Порядок членов класса:
    *   Группировать члены класса в следующем порядке:
        *   Вложенные классы, перечисления, делегаты, события.
        *   Поля (сначала должны идти const, static, readonly).
        *   Конструкторы и деструкторы.
        *   Свойства.
        *   Методы.
    *   В каждой группе элементы должны располагаться в следующем порядке:
        *   Public.
        *   Internal.
        *   Protected internal.
        *   Protected.
        *   Private protected.
        *   Private.
    *   Где это возможно, группируйте реализации интерфейсов вместе.

### Правила расстановки пробелов

Developed from Google Java style.

*   Максимум одно выражение в строке.
*   Максимум одно присваивание в строке.
*   Используется не более четырех уровней вложенности кода
*   Отступы кратны 4 пробелам, Tab не используется.
*   Максимальное число символов в строке: 120.
*   Нет перехода на новую строку перед открывающейся фигурной скобкой.
*   Нет перехода на новую строку между закрывающейся фигурной скобкой и else / catch / finally.
*   Фигурные скобки используется, даже если они не обязательны.
*   После запятых ставится пробел.
*   Нет пробелов после открывающейся скобкой и перед закрывающейся скобкой.
*   Нет пробелов между унарным оператором и его операндом. 
    Один пробел между оператором и операндом во всех остальных случаях.
*   Правила переноса строк:
    *   Если длинное выражение не помещается на 1 строку, 
        то к каждой новой строке добавляется отступ кратно 4 пробелам.
    *   При определении и вызове методов, если аргументы не умещаются в одной строке, они должны быть 
        разбиты на несколько строк. Каждая последующая строка выравнивается по первому аргументу. 
        Если для этого не хватает места, то все аргументы могут быть вместе перенесены на следующую строку 
        с отступом в 4 пробела.


### Example

```c#
using System;                                           // `using` находится сверху, вне объявления
                                                        // namespace.

namespace MyNamespace {                                 // Для Namespaces используется PascalCase.
    public interface IMyInterface {                     // Для интерфейса начинается с 'I'.
        public int Calculate(float value, float exp);   // Для метода используется PascalCase.
                                                        // ...and space after comma.
    }

    public enum MyEnum {                                // Для перечислений используется PascalCase.
        Yes,                                            
        No,
    }

    public class MyClass {                              // Для класса используется PascalCase.
        public int Foo = 0;                             // Для публичных членов класса используется PascalCase.
        public bool NoCounting = false;                 // Инициализаторы полей приветствуются.
        private class Results {
            public int NumNegativeResults = 0;
            public int NumPositiveResults = 0;
        }

        private Results _results;                       // Для приватных членов класса используется _camelCase.
        public static int NumTimesCalled = 0;
        private const int _bar = 100;                   // const не влияют на правила именования.

        private int[] _someTable = {                    // При переходе на новую строку добавляются 4 пробела.
            2, 3, 4,                                    
        };

        public MyClass() {
            _results = new Results {
                NumNegativeResults = 1,                 // При переходе на новую строку добавляются 4 пробела.
                NumPositiveResults = 1,
            };
        }

        public int CalculateValue(int mulNumber) {      // Нет перехода на новую строку перед символом '{'.
            var resultValue = Foo * mulNumber;          // Для локальных переменных используется camelCase.
            NumTimesCalled++;
            Foo += _bar;

            if (!NoCounting) {                          // Нет пробелов перед унарным оператором.
                if (resultValue < 0) {                  // Пробелы вокруг оператора сравнения.                                                        
                    _results.NumNegativeResults++;      // Скобки используются, даже, если они необязательны.
                } else if (resultValue > 0) {           // Нет перехода на новую строку между else и '}'.
                    _results.NumPositiveResults++;
                }
            }

            return resultValue;
        }

        public void ExpressionBodies() {
            // Простые лямбда-выражения помещайте в одну строку, если это возможно.
            Func<int, int> increment = x => x + 1;

            // Закрывающая фигурная скобка выравнивается по первому символу строки с открывающей скобкой.
            Func<int, int, long> difference1 = (x, y) => {
                long diff = (long)x - y;
                return diff >= 0 ? diff : -diff;
            };

            // Если определенние переносится на новую строку, то отступ имеет все тело объекта.
            Func<int, int, long> difference2 =
                (x, y) => {
                    long diff = (long)x - y;
                    return diff >= 0 ? diff : -diff;
                };

            // Встроенные лямбда-аргументы тоже следуют этому правилу. Предпочитайте дополнительную
            // новую строку перед группой аргументов, которые включают лямбда-выражение.
            CallWithDelegate(
                (x, y) => {
                    long diff = (long)x - y;
                    return diff >= 0 ? diff : -diff;
                });
            }

            void DoNothing() {}                         // Пустые блоки могут быть краткими.

            // Старайтесь выравнивать аргументы на новой строке по первому аргументу.
            void AVeryLongFunctionNameThatCausesLineWrappingProblems(int longArgumentName,
                                                                     int p1, int p2) {}

            // Если перенос части аргументов не дает достаточно места, то могут быть перенесены 
            // все аргументы с отступом в 4 пробела.
            void AnotherLongFunctionNameThatCausesLineWrappingProblems(
                int longArgumentName, int longArgumentName2, int longArgumentName3) {}

            void CallingLongFunctionName() {
                int veryLongArgumentName = 1234;
                int shortArg = 1;
            // Старайтесь выравнивать аргументы на новой строке по первому аргументу.
            AnotherLongFunctionNameThatCausesLineWrappingProblems(shortArg, shortArg,
                                                                  veryLongArgumentName);

            // Если перенос части аргументов не дает достаточно места, то могут быть перенесены 
            // все аргументы с отступом в 4 пробела.
            AnotherLongFunctionNameThatCausesLineWrappingProblems(
                veryLongArgumentName, veryLongArgumentName, veryLongArgumentName);
        }
    }
}
```


## Рекомендации по написанию кода на C#

### Константы

*   Переменные и поля, которые могут быть сделаны const, всегда следует делать const.
*   Если `const` не подходит, то `readonly` может быть подходящей альтернативой.
*   Предпочитайте именованные константы «магическим числам и словам».

### IEnumerable vs IList vs IReadOnlyList

*   В качестве входящих данных используйте самый строгий тип коллекции, например, 
    `IReadOnlyCollection` / `IReadOnlyList` / `IEnumerable`, как входные данные методов, 
    если входные данные должны быть неизменными.
*   Для возвращаемых данных, когда коллекция полностью передается во владение вызывающему методу, 
    предпочитайте `IList`, а не `IEnumerable`. 
    Если коллекция на самом деле находится в коде, который вызывается, т.е. если коллекция - 
    это внутренний член объекта, на котором был вызван метод по получению этой коллекции, 
    то необходимо использовать самый строгий вариант.

### Generators vs containers

*   Выбирайте лучший вариант, учитывая следующее:
    *   Генератор менее читаем по сравнению с заполнением контейнера.
    *   Генератор может быть более производительным, если результаты будут 
        обрабатываться лениво, например, если не требуются все результаты.
    *   Генератор напрямую обращенный в контейнер с помощью `ToList()` 
        будет менее производительным, чем непосредственное заполнение контейнера.
    *   Генератор, вызываемый несколько раз, будет значительно медленнее, 
        чем многократная итерация контейнера.

### Стили свойств

*   Для одиночных readonly свойств предпочтительнее использовать тело-выражение (`=>`), где это возможно.
*   Для остальных случаев используйте более старый `{ get; set; }` синтаксис.

### Синтаксис тела-выражения

Пример:

```c#
int SomeProperty => _someProperty
```

*   Разумно используйте тело-выражение в лямбдах и свойствах.
*   Не используйте тело-выражение в определениях методов.
*   Для методов и других выделенных скобками блоков кода, 
    выравнивайте первый символ строки, который содержит открывающую фигурную скобку.

### Структуры и классы:

*   Структуры очень сильно отличаются от классов:

    *   Структуры всегда передаются и возвращаются по значению.
    *   Присвоение значение члену структуры, которая была возвращена не изменяет оригинал. 
        Пример: `transform.position.x = 10`, не установит значение свойству transform.position.x значение 10,
        потому что `position` возвращается в этом случае как значение, т.е. значение устанавливается копии оригиналу.

*   Почти всегда используйте классы.

*   Рассмотрите структуру для использования, когда тип можно рассмотреть как другие типы значений, 
    например, если экземпляры типа маленькие и обычно недолго существуют или когда обычно встроены в другие объекты. 
    Хорошими примерами реализации являются Vector3, Quaternion и Bounds.

*   Обратите внимание, что эти рекомендации могут отличаться от команды к команде, 
    например, в случае, когда проблемы быстродействия могут заставить применять структуры.

### Лямбды vs именованные методы

*    Если лямбда-выражение не очевидное (например, несколько выражений без учета объявлений) 
     или используется в нескольких местах, то это скорее всего должен быть именованный метод.


### Инициализаторы полей

*   Инициализаторы полей обычно рекомендуются к использованию.

### Методы-расширения

*   Используйте методы-расширения только, когда исходный код класса недоступен 
    или когда изменение исходного кода не представляется возможным.
*   Используйте методы-расширения только, если добавляемый функционал является
    «основной» функцией, которую было бы целесообразно добавить к исходному классу.
    *   Обратите внимание, если у нас есть доступ к источнику расширяемого класса 
        и его владелец не хочет добавлять функционал, то лучше не использовать методы расширения.
*   Добавляете методы-расширения только в библиотеки, которые доступны отовсюду – расширения, 
    которые доступны только в части кода создадут проблемы читаемости.
*   Имейте в виду, что методы расширения всегда запутывают код. Поэтому лучше не добавлять их.

### ref и out

*   Не используйте ref и out?

### LINQ

*   В основном предпочитайте однострочные LINQ вызовы и императивный код, чем длинные цепочки LINQ выражений. 
    Смешение императивного кода и длинных LINQ цепочек часто сложно читать.
*   Предпочитайте методы-расширения ключевым словам в SQL-стиле, 
    например, предпочтительнее `myList.Where(x)`, чем `myList where x`.
*   Избегайте `Container.ForEach(...)` для чего угодно длиннее одного выражения.

### Array vs List

*   В основном предпочитайте `List<>` массивам для публичных переменных, свойств 
    и возвращаемых типов (держите в уме рекомендации по `IList` / `IEnumerable` / `IReadOnlyList`, описанные выше)
*   Предпочитайте `List<>`, когда размер контейнера может измениться..
*   Предпочитайте массивы, когда размер контейнера фиксированный и известен в момент создания.
*   Предпочитайте массив для многомерных массивов.
*   Обратите внимание:
    *   Массив и `List<>` оба представляют линейные, смежные контейнеры.
    *   Подобно arrays и `std::vector` в C++, массивы фиксированы по вместимости, а `List<>` может быть расширен.
    *   В большинстве случаев массивы более производительны, но в основном `List<>` более гибкий.

### Папки и расположение файлов

*   Будьте последовательны в своем проекте.
*   Предпочитайте плоскую структуру, где это возможно.

### Использование tuple как возвращаемое значение

*   Используйте именованные кортежи вместо встроенных, но лучше создать класс
*   В основном предпочитайте именованные классы типу `Tuple<>`, особенно при возврате сложных типов.

### String interpolation vs `String.Format()` vs `String.Concat` vs `operator+`

*   Старайтесь всегда использовать интерполяцию строк, если это возможно. 
    В остальных случаях и при работе с большим объемом текста рекомендуется 
    использовать StringBuilder вместо конкатенации строки.

### `using`

*   В основном не используйте длинные псевдонимы с `using`. 
    Часто это признак того, что кортеж `Tuple<>` должен быть обращен в класс.
    *   Например, `using RecordList = List<Tuple<int, float>>` 
        возможно должен быть именованным классом.
*   Имейте ввиду, что `using` имеет область видимости только на уровне файлов (*.cs). 
    Но начиная с C# 10.0 появилась возможность объявлять `global using`.

### Синтаксис инициализации объектов

Пример:

```c#
var x = new SomeClass {
  Property1 = value1,
  Property2 = value2,
};
```

*   Синтаксис инициализации объектов подходит для типов ‘plain old data’.
*   Избегайте использования этого синтаксиса для классов или структур, которые имеют конструкторы.
*   При разделении на несколько строк, делайте отступ в один блок (4 пробела)

### Наименование пространств имен

*   В основном пространства имен не должны быть в глубину больше 2 уровней
*   Не заставляйте структуры файлов/папок соответствовать пространствам имен.
*   Для общедоступных библиотек/модулей кода используйте пространства имен. 
    Для конечного кода приложения, такого как `unity_app`, пространства имен не обязательны.
*   Новые пространства имен верхнего уровня должны быть узнаваемы и уникальны.

### Значения по умолчанию, возвращение null для структур

*   Параметр `out` допускается использовать только в методах типа “TryGet”, 
    например, `success = int.TryParse(value, out number)`
*   Если вопрос производительности не является критичным, то рекомендуется использовать…
*   Рекомендуется использовать тернарный оператор, если есть такая возможность и это увеличивает читаемость кода.
*   Рекомендуется добавлять проверки на null для типов, допускающих null. 
    Варианты проверки на null:
    *   Null-conditional operator, например, `width = element?.width`.
    *   Null-coalescing operators, например, `name = text ?? "UserName" и name ??= "UserName"`.
    

### Удаление из контейнеров во время итерации

C# (как и большинство других языков) не предоставляет очевидный механизм 
для удаления объектов в процессе итерации. Существует несколько вариантов:

*   Если все, что требуется это удалить некоторые элементы, удовлетворяющие какому-то условию, 
    рекомендуется использовать `someList.RemoveAll(somePredicate)`.
*   Если требуются другие действия в процессе итерации, `RemoveAll` может быть недостаточно. 
    Общий альтернативный шаблон — это создать новый контейнер вне цикла, добавлять необходимые элементы 
    в новый контейнер и заменить исходный контейнер на новый после итерации. 
    Для этого нужно использовать LINQ и метод Where.

### Вызов делегатов

*   При вызове делегата используйте `Invoke()` и оператор null-conditional, то есть `SomeDelegate?.Invoke()`. 
    Это лучше отражает вызов делегата, и его сложно будет спутать с методом.

### Ключевое слов `var`

*   Использование `var` приветствуется, если это способствует повышению читаемости 
    и позволяет избежать шумных, очевидных и неважных имен типов.

*   Приветствуется:

    *   Когда тип очевиден, например, `var apple = new Apple();`, или `var
        request = Factory.Create<HttpRequest>();`
    *   Для временных переменных, которые только проходят через другие методы, 
        например, `var item = GetItem(); ProcessItem(item);`

*   Не приветствуется:

    *   При работе с базовыми типами, например, `var success = true;`
    *   При работе с встроенными числовыми переменными, которые определяются компилятором, 
        например, `var number = 12 * ReturnsFloat();`
    *   Когда пользователи точно получат пользу от того, что знают тип, например, 
        `var listOfItems = GetList();`

### Атрибуты

*   Атрибуты должны появляться на строке выше поля, свойства или метода, 
    к которому они относятся, с переходом на новую строку.
*   Каждый атрибут должен начинаться с новой строки. Это позволяет легче добавлять или 
    удалять атрибуты и обеспечивает удобный поиск каждого атрибута.

### Именование аргументов

Взято из Google C++ style guide.

Когда значение аргумента метода не очевидно, рассмотрите один из следующих принципов:

*   Если аргумент — это литерал, и эта константа используется в нескольких вызовах методов способом,
    который предполагает, что они идентичны, используйте именованную константу,
    чтобы сделать это ограничение явным и гарантировать, что оно выполняется.
*   Рассмотрите изменение сигнатуры метода, чтобы заменить bool аргументы на enum аргументы.
    Это поможет понять, что значат эти аргументы.
*   Замените большие и сложные вложенные выражения именованными переменными.

*   Рассмотрите возможность использования
    [именованных аргументов](https://learn.microsoft.com/ru-ru/dotnet/csharp/programming-guide/classes-and-structs/named-and-optional-arguments)
    для прояснения значений аргументов при вызове.
*   Для методов, которые имеют несколько параметров конфигурации, рассмотрите создание класса или структуры
    для хранения всех этих параметров и использование экземпляра в качестве аргумента.
    Это имеет несколько преимуществ. Параметры упоминаются по имени при вызове, что проясняет их значение.
    Также это снижает количество аргументов метода, что позволяет проще читать и создавать вызов метода.
    Как дополнительное преимущество, это позволяет не менять вызов метода при добавлении нового параметра.

Рассмотрим пример:

```c#
// Плохо - что это за аргументы?
DecimalNumber product = CalculateProduct(values, 7, false, null);
```

против:

```c#
// Хорошо
ProductOptions options = new ProductOptions();
options.PrecisionDecimals = 7;
options.UseCache = CacheUsage.DontUseCache;
DecimalNumber product = CalculateProduct(values, options, completionDelegate: null);
```